<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zen-C: Zen-C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Zen-C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Zen-C </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p><div align="center"></div><div align="center"><a class="el" href="index.html#md_README">English</a> • Русский • 简体中文 • 繁體中文 • Español • Italiano • Português Brasileiro</div><div align="center"></div><div align="center"></div><div align="center"></div><h1><a class="anchor" id="autotoc_md0"></a>
Zen C</h1>
<div align="center"></div><div align="center"><b>Modern Ergonomics. Zero Overhead. Pure C.</b></div><div align="center">[<img src="https://img.shields.io/badge/build-passing-brightgreen" alt="Build Status" class="inline"/>]() [<img src="https://img.shields.io/badge/license-MIT-blue" alt="License" class="inline"/>]() [<img src="https://img.shields.io/github/v/release/z-libs/Zen-C?label=version&amp;color=orange" alt="Version" class="inline"/>]() [<img src="https://img.shields.io/badge/platform-linux-lightgrey" alt="Platform" class="inline"/>]()</div><div align="center"><em>Write like a high-level language, run like C.</em></div><div align="center"></div><hr  />
<h2><a class="anchor" id="autotoc_md2"></a>
Overview</h2>
<p><b>Zen C</b> is a modern systems programming language that compiles to human-readable <code>GNU C</code>/<code>C11</code>. It provides a rich feature set including type inference, pattern matching, generics, traits, async/await, and manual memory management with RAII capabilities, all while maintaining 100% C ABI compatibility.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Community</h2>
<p>Join the discussion, share demos, ask questions, or report bugs in the official Zen C Discord server!</p>
<ul>
<li>Discord: <a href="https://discord.com/invite/q6wEsCmkJP">Join here</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md5"></a>
Index</h2>
<ul>
<li>Overview</li>
<li>Community</li>
<li>Quick Start<ul>
<li>Installation</li>
<li>Usage</li>
<li>Environment Variables</li>
</ul>
</li>
<li>Language Reference<ul>
<li>1. Variables and Constants</li>
<li>2. Primitive Types</li>
<li>3. Aggregate Types<ul>
<li>Arrays</li>
<li>Tuples</li>
<li>Structs</li>
<li>Opaque Structs</li>
<li>Enums</li>
<li>Unions</li>
<li>Type Aliases</li>
<li>Opaque Type Aliases</li>
</ul>
</li>
<li>4. Functions &amp; Lambdas<ul>
<li>Functions</li>
<li>Const Arguments</li>
<li>Default Arguments</li>
<li>Lambdas (Closures)</li>
<li>Raw Function Pointers</li>
<li>Variadic Functions</li>
</ul>
</li>
<li>5. Control Flow<ul>
<li>Conditionals</li>
<li>Pattern Matching</li>
<li>Loops</li>
<li>Advanced Control</li>
</ul>
</li>
<li>6. Operators<ul>
<li>Overloadable Operators</li>
<li>Syntactic Sugar</li>
</ul>
</li>
<li>7. Printing and String Interpolation<ul>
<li>Keywords</li>
<li>Shorthands</li>
<li>String Interpolation (F-strings)</li>
<li>Input Prompts (`?`)</li>
</ul>
</li>
<li>8. Memory Management<ul>
<li>Defer</li>
<li>Autofree</li>
<li>Resource Semantics (Move by Default)</li>
<li>RAII / Drop Trait</li>
</ul>
</li>
<li>9. Object Oriented Programming<ul>
<li>Methods</li>
<li>Traits</li>
<li>Standard Traits</li>
<li>Composition</li>
</ul>
</li>
<li>10. Generics</li>
<li>11. Concurrency (Async/Await)</li>
<li>12. Metaprogramming<ul>
<li>Comptime</li>
<li>Embed</li>
<li><a class="el" href="dir_38c8d24aef3972a7f87b834274e76e31.html">Plugins</a></li>
<li>Generic C Macros</li>
</ul>
</li>
<li>13. Attributes</li>
<li>Custom Attributes</li>
<li>Smart Derives</li>
<li>14. Inline Assembly<ul>
<li>Basic Usage</li>
<li>Volatile</li>
<li>Named Constraints</li>
</ul>
</li>
<li>15. Build Directives</li>
<li>16. Keywords</li>
<li>17. C Interoperability</li>
</ul>
</li>
<li>Standard Library</li>
<li>Tooling<ul>
<li>Language Server (LSP)</li>
<li>REPL</li>
</ul>
</li>
<li>Compiler Support &amp; Compatibility<ul>
<li>Test Suite Status</li>
<li>Building with Zig</li>
<li>C++ Interop</li>
<li>CUDA Interop</li>
<li>Objective-C Interop</li>
<li>C23 Support</li>
</ul>
</li>
<li>Contributing</li>
<li>Attributions</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md7"></a>
Quick Start</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Installation</h3>
<div class="fragment"><div class="line">git clone https://github.com/z-libs/Zen-C.git</div>
<div class="line">cd Zen-C</div>
<div class="line">make</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Portable Build (APE)</h3>
<p>Zen C can be compiled as an <b>Actually Portable Executable (APE)</b> using <a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a>. This produces a single binary (<code>.com</code>) that runs natively on Linux, macOS, Windows, FreeBSD, OpenBSD, and NetBSD on both x86_64 and aarch64 architectures.</p>
<p><b>Prerequisites:</b></p><ul>
<li><code>cosmocc</code> toolchain (must be in your PATH)</li>
</ul>
<p><b>Build &amp; Install:</b> </p><div class="fragment"><div class="line">make ape</div>
<div class="line">sudo env &quot;PATH=$PATH&quot; make install-ape</div>
</div><!-- fragment --><p><b>Artifacts:</b></p><ul>
<li><code>out/bin/zc.com</code>: The portable Zen-C compiler. Includes the standard library embedded within the executable.</li>
<li><code>out/bin/zc-boot.com</code>: A self-contained bootstrap installer for setting up new Zen-C projects.</li>
</ul>
<p><b>Usage:</b> </p><div class="fragment"><div class="line"># Run on any supported OS</div>
<div class="line">./out/bin/zc.com build hello.zc -o hello</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Usage</h3>
<div class="fragment"><div class="line"># Compile and run</div>
<div class="line">zc run hello.zc</div>
<div class="line"> </div>
<div class="line"># Build executable</div>
<div class="line">zc build hello.zc -o hello</div>
<div class="line"> </div>
<div class="line"># Interactive Shell</div>
<div class="line">zc repl</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Environment Variables</h3>
<p>You can set <code>ZC_ROOT</code> to specify the location of the Standard Library (standard imports like <code>import "std/vec.zc"</code>). This allows you to run <code>zc</code> from any directory.</p>
<div class="fragment"><div class="line">export ZC_ROOT=/path/to/Zen-C</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md13"></a>
Language Reference</h2>
<h3><a class="anchor" id="autotoc_md14"></a>
1. Variables and Constants</h3>
<p>Zen C distinguishes between compile-time constants and runtime variables.</p>
<h4><a class="anchor" id="autotoc_md15"></a>
Manifest Constants (&lt;tt&gt;def&lt;/tt&gt;)</h4>
<p>Values that exist only at compile-time (folded into code). Use these for array sizes, fixed configuration, and magic numbers.</p>
<div class="fragment"><div class="line">def MAX_SIZE = 1024;</div>
<div class="line">let buffer: char[MAX_SIZE]; // Valid array size</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md16"></a>
Variables (&lt;tt&gt;let&lt;/tt&gt;)</h4>
<p>Storage locations in memory. Can be mutable or read-only (<code>const</code>).</p>
<div class="fragment"><div class="line">let x = 10;             // Mutable</div>
<div class="line">x = 20;                 // OK</div>
<div class="line"> </div>
<div class="line">let y: const int = 10;  // Read-only (Type qualified)</div>
<div class="line">// y = 20;              // Error: cannot assign to const</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b><a class="el" href="structType.html" title="Represents a formal type in the type system.">Type</a> Inference</b>: Zen C automatically infers types for initialized variables. It compiles to C23 <code>auto</code> on supported compilers, or GCC's <code>__auto_type</code> extension otherwise. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md17"></a>
2. Primitive Types</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><a class="el" href="structType.html" title="Represents a formal type in the type system.">Type</a>   </th><th class="markdownTableHeadLeft">C Equivalent   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>int</code>, <code>uint</code>   </td><td class="markdownTableBodyLeft"><code>int32_t</code>, <code>uint32_t</code>   </td><td class="markdownTableBodyLeft">32-bit signed/unsigned integer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>c_char</code>, <code>c_uchar</code>   </td><td class="markdownTableBodyLeft"><code>char</code>, <code>unsigned char</code>   </td><td class="markdownTableBodyLeft">C char / unsigned char (Interop)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>c_short</code>, <code>c_ushort</code>   </td><td class="markdownTableBodyLeft"><code>short</code>, <code>unsigned short</code>   </td><td class="markdownTableBodyLeft">C short / unsigned short (Interop)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>c_int</code>, <code>c_uint</code>   </td><td class="markdownTableBodyLeft"><code>int</code>, <code>unsigned int</code>   </td><td class="markdownTableBodyLeft">C int / unsigned int (Interop)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>c_long</code>, <code>c_ulong</code>   </td><td class="markdownTableBodyLeft"><code>long</code>, <code>unsigned long</code>   </td><td class="markdownTableBodyLeft">C long / unsigned long (Interop)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>I8</code> .. <code>I128</code> or <code>i8</code> .. <code>i128</code>   </td><td class="markdownTableBodyLeft"><code>int8_t</code> .. <code>__int128_t</code>   </td><td class="markdownTableBodyLeft">Signed fixed-width integers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>U8</code> .. <code>U128</code> or <code>u8</code> .. <code>u128</code>   </td><td class="markdownTableBodyLeft"><code>uint8_t</code> .. <code>__uint128_t</code>   </td><td class="markdownTableBodyLeft">Unsigned fixed-width integers    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>isize</code>, <code>usize</code>   </td><td class="markdownTableBodyLeft"><code>ptrdiff_t</code>, <code>size_t</code>   </td><td class="markdownTableBodyLeft">Pointer-sized integers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>byte</code>   </td><td class="markdownTableBodyLeft"><code>uint8_t</code>   </td><td class="markdownTableBodyLeft">Alias for U8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>F32</code>, <code>F64</code> or <code>f32</code>, <code>f64</code>   </td><td class="markdownTableBodyLeft"><code>float</code>, <code>double</code>   </td><td class="markdownTableBodyLeft">Floating point numbers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>bool</code>   </td><td class="markdownTableBodyLeft"><code>bool</code>   </td><td class="markdownTableBodyLeft"><code>true</code> or <code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>char</code>   </td><td class="markdownTableBodyLeft"><code>char</code>   </td><td class="markdownTableBodyLeft">Single character    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>string</code>   </td><td class="markdownTableBodyLeft"><code>char*</code>   </td><td class="markdownTableBodyLeft">C-string (null-terminated)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>U0</code>, <code>u0</code>, <code>void</code>   </td><td class="markdownTableBodyLeft"><code>void</code>   </td><td class="markdownTableBodyLeft">Empty type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>iN</code> (for example, <code>i256</code>)   </td><td class="markdownTableBodyLeft"><code>_BitInt(N)</code>   </td><td class="markdownTableBodyLeft">Arbitrary bit-width signed integer (C23)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>uN</code> (for example, <code>u42</code>)   </td><td class="markdownTableBodyLeft"><code>unsigned _BitInt(N)</code>   </td><td class="markdownTableBodyLeft">Arbitrary bit-width unsigned integer (C23)   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;<b>Best Practices for Portable Code</b></p>
<ul>
<li>Use <b>Portable Types</b> (<code>int</code>, <code>uint</code>, <code>i64</code>, <code>u8</code>, etc.) for all pure Zen C logic. <code>int</code> is guaranteed to be 32-bit signed on all architectures.</li>
<li>Use <b>C Interop Types</b> (<code>c_int</code>, <code>c_char</code>, <code>c_long</code>) <b>only</b> when interacting with C libraries (FFI). Their size varies by platform and C compiler (e.g. <code>c_long</code> size differs between Windows and Linux).</li>
<li>Use <code>isize</code> and <code>usize</code> for array indexing and memory pointer arithmetic. </li>
</ul>
</blockquote>
<h3><a class="anchor" id="autotoc_md18"></a>
3. Aggregate Types</h3>
<h4><a class="anchor" id="autotoc_md19"></a>
Arrays</h4>
<p>Fixed-size arrays with value semantics. </p><div class="fragment"><div class="line">def SIZE = 5;</div>
<div class="line">let ints: int[SIZE] = [1, 2, 3, 4, 5];</div>
<div class="line">let zeros: [int; SIZE]; // Zero-initialized</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md20"></a>
Tuples</h4>
<p>Group multiple values together, access elements by index. </p><div class="fragment"><div class="line">let pair = (1, &quot;Hello&quot;);</div>
<div class="line">let x = pair.0;  // 1</div>
<div class="line">let s = pair.1;  // &quot;Hello&quot;</div>
</div><!-- fragment --><p><b>Multiple Return Values</b></p>
<p>Functions can return tuples to provide multiple results: </p><div class="fragment"><div class="line">fn add_and_subtract(a: int, b: int) -&gt; (int, int) {</div>
<div class="line">    return (a + b, a - b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">let result = add_and_subtract(3, 2);</div>
<div class="line">let sum = result.0;   // 5</div>
<div class="line">let diff = result.1;  // 1</div>
</div><!-- fragment --><p><b>Destructuring</b></p>
<p>Tuples can be destructured directly into variables: </p><div class="fragment"><div class="line">let (sum, diff) = add_and_subtract(3, 2);</div>
<div class="line">// sum = 5, diff = 1</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md21"></a>
Structs</h4>
<p>Data structures with optional bitfields. </p><div class="fragment"><div class="line">struct Point {</div>
<div class="line">    x: int;</div>
<div class="line">    y: int;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Struct initialization</div>
<div class="line">let p = Point { x: 10, y: 20 };</div>
<div class="line"> </div>
<div class="line">// Bitfields</div>
<div class="line">struct Flags {</div>
<div class="line">    valid: U8 : 1;</div>
<div class="line">    mode:  U8 : 3;</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note</b>: Structs use Move Semantics by default. Fields can be accessed via <code>.</code> even on pointers (Auto-Dereference). </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md22"></a>
Opaque Structs</h4>
<p>You can define a struct as <code>opaque</code> to restrict access to its fields to the defining module only, while still allowing the struct to be allocated on the stack (size is known).</p>
<div class="fragment"><div class="line">// In user.zc</div>
<div class="line">opaque struct User {</div>
<div class="line">    id: int;</div>
<div class="line">    name: string;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn new_user(name: string) -&gt; User {</div>
<div class="line">    return User{id: 1, name: name}; // OK: Inside module</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// In main.zc</div>
<div class="line">import &quot;user.zc&quot;;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let u = new_user(&quot;Alice&quot;);</div>
<div class="line">    // let id = u.id; // Error: Cannot access private field &#39;id&#39;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md23"></a>
Enums</h4>
<p>Tagged unions (Sum types) capable of holding data. </p><div class="fragment"><div class="line">enum Shape {</div>
<div class="line">    Circle(float),      // Holds radius</div>
<div class="line">    Rect(float, float), // Holds width, height</div>
<div class="line">    Point               // No data</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md24"></a>
Unions</h4>
<p>Standard C unions (unsafe access). </p><div class="fragment"><div class="line">union Data {</div>
<div class="line">    i: int;</div>
<div class="line">    f: float;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md25"></a>
Type Aliases</h4>
<p>Create a new name for an existing type. </p><div class="fragment"><div class="line">alias ID = int;</div>
<div class="line">alias PointMap = Map&lt;string, Point&gt;;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md26"></a>
Opaque Type Aliases</h4>
<p>You can define a type alias as <code>opaque</code> to create a new type that is distinct from its underlying type outside of the defining module. This provides strong encapsulation and type safety without the runtime overhead of a wrapper struct.</p>
<div class="fragment"><div class="line">// In library.zc</div>
<div class="line">opaque alias Handle = int;</div>
<div class="line"> </div>
<div class="line">fn make_handle(v: int) -&gt; Handle {</div>
<div class="line">    return v; // Implicit conversion allowed inside module</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// In main.zc</div>
<div class="line">import &quot;library.zc&quot;;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let h: Handle = make_handle(42);</div>
<div class="line">    // let i: int = h; // Error: Type validation failed</div>
<div class="line">    // let h2: Handle = 10; // Error: Type validation failed</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
4. Functions &amp; Lambdas</h3>
<h4><a class="anchor" id="autotoc_md28"></a>
Functions</h4>
<div class="fragment"><div class="line">fn add(a: int, b: int) -&gt; int {</div>
<div class="line">    return a + b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Named arguments supported in calls</div>
<div class="line">add(a: 10, b: 20);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note</b>: Named arguments must strictly follow the defined parameter order. <code>add(b: 20, a: 10)</code> is invalid. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md29"></a>
Const Arguments</h4>
<p>Function arguments can be marked as <code>const</code> to enforce read-only semantics. This is a type qualifier, not a manifest constant.</p>
<div class="fragment"><div class="line">fn print_val(v: const int) {</div>
<div class="line">    // v = 10; // Error: Cannot assign to const variable</div>
<div class="line">    println &quot;{v}&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md30"></a>
Default Arguments</h4>
<p>Functions can define default values for trailing arguments. These can be literals, expressions, or valid Zen C code (like struct constructors). </p><div class="fragment"><div class="line">// Simple default value</div>
<div class="line">fn increment(val: int, amount: int = 1) -&gt; int {</div>
<div class="line">    return val + amount;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Expression default value (evaluated at call site)</div>
<div class="line">fn offset(val: int, pad: int = 10 * 2) -&gt; int {</div>
<div class="line">    return val + pad;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Struct default value</div>
<div class="line">struct Config { debug: bool; }</div>
<div class="line">fn init(cfg: Config = Config { debug: true }) {</div>
<div class="line">    if cfg.debug { println &quot;Debug Mode&quot;; }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    increment(10);      // 11</div>
<div class="line">    offset(5);          // 25</div>
<div class="line">    init();             // Prints &quot;Debug Mode&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md31"></a>
Lambdas (Closures)</h4>
<p>Anonymous functions that can capture their environment. </p><div class="fragment"><div class="line">let factor = 2;</div>
<div class="line">let double = x -&gt; x * factor;  // Arrow syntax</div>
<div class="line">let full = fn(x: int) -&gt; int { return x * factor; }; // Block syntax</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md32"></a>
Raw Function Pointers</h4>
<p>Zen C supports raw C function pointers using the <code>fn*</code> syntax. This allows seamless interop with C libraries that expect function pointers without closure overhead.</p>
<div class="fragment"><div class="line">// Function taking a raw function pointer</div>
<div class="line">fn set_callback(cb: fn*(int)) {</div>
<div class="line">    cb(42);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Function returning a raw function pointer</div>
<div class="line">fn get_callback() -&gt; fn*(int) {</div>
<div class="line">    return my_handler;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Pointers to function pointers are supported (fn**)</div>
<div class="line">let pptr: fn**(int) = &amp;ptr;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md33"></a>
Variadic Functions</h4>
<p>Functions can accept a variable number of arguments using <code>...</code> and the <code>va_list</code> type. </p><div class="fragment"><div class="line">fn log(lvl: int, fmt: char*, ...) {</div>
<div class="line">    let ap: va_list;</div>
<div class="line">    va_start(ap, fmt);</div>
<div class="line">    vprintf(fmt, ap); // Use C stdio</div>
<div class="line">    va_end(ap);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
5. Control Flow</h3>
<h4><a class="anchor" id="autotoc_md35"></a>
Conditionals</h4>
<div class="fragment"><div class="line">if x &gt; 10 {</div>
<div class="line">    print(&quot;Large&quot;);</div>
<div class="line">} else if x &gt; 5 {</div>
<div class="line">    print(&quot;Medium&quot;);</div>
<div class="line">} else {</div>
<div class="line">    print(&quot;Small&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Ternary</div>
<div class="line">let y = x &gt; 10 ? 1 : 0;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md36"></a>
Pattern Matching</h4>
<p>Powerful alternative to <code>switch</code>. </p><div class="fragment"><div class="line">match val {</div>
<div class="line">    1         =&gt; { print &quot;One&quot; },</div>
<div class="line">    2 || 3    =&gt; { print &quot;Two or Three&quot; },    // OR with ||</div>
<div class="line">    4 or 5    =&gt; { print &quot;Four or Five&quot; },    // OR with &#39;or&#39;</div>
<div class="line">    6, 7, 8   =&gt; { print &quot;Six to Eight&quot; },    // OR with comma</div>
<div class="line">    10 .. 15  =&gt; { print &quot;10 to 14&quot; },        // Exclusive range (Legacy)</div>
<div class="line">    10 ..&lt; 15 =&gt; { print &quot;10 to 14&quot; },        // Exclusive range (Explicit)</div>
<div class="line">    20 ..= 25 =&gt; { print &quot;20 to 25&quot; },        // Inclusive range</div>
<div class="line">    _         =&gt; { print &quot;Other&quot; },</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Destructuring Enums</div>
<div class="line">match shape {</div>
<div class="line">    Shape::Circle(r)   =&gt; { println &quot;Radius: {r}&quot; },</div>
<div class="line">    Shape::Rect(w, h)  =&gt; { println &quot;Area: {w*h}&quot; },</div>
<div class="line">    Shape::Point       =&gt; { println &quot;Point&quot; },</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md37"></a>
Reference Binding</h4>
<p>To inspect a value without taking ownership (moving it), use the <code>ref</code> keyword in the pattern. This is essential for types that implement Move Semantics (like <code>Option</code>, <code>Result</code>, non-Copy structs).</p>
<div class="fragment"><div class="line">let opt = Some(NonCopyVal{...});</div>
<div class="line">match opt {</div>
<div class="line">    Some(ref x) =&gt; {</div>
<div class="line">        // &#39;x&#39; is a pointer to the value inside &#39;opt&#39;</div>
<div class="line">        // &#39;opt&#39; is NOT moved/consumed here</div>
<div class="line">        println &quot;{x.field}&quot;; </div>
<div class="line">    },</div>
<div class="line">    None =&gt; {}</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md38"></a>
Loops</h4>
<div class="fragment"><div class="line">// Range</div>
<div class="line">for i in 0..10 { ... }      // Exclusive (0 to 9)</div>
<div class="line">for i in 0..&lt;10 { ... }     // Exclusive (Explicit)</div>
<div class="line">for i in 0..=10 { ... }     // Inclusive (0 to 10)</div>
<div class="line">for i in 0..10 step 2 { ... }</div>
<div class="line"> </div>
<div class="line">// Iterator (Vec or custom Iterable)</div>
<div class="line">for item in vec { ... }</div>
<div class="line"> </div>
<div class="line">// Iterate over fixed-size arrays directly</div>
<div class="line">let arr: int[5] = [1, 2, 3, 4, 5];</div>
<div class="line">for val in arr {</div>
<div class="line">    // val is int</div>
<div class="line">    println &quot;{val}&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// While</div>
<div class="line">while x &lt; 10 { ... }</div>
<div class="line"> </div>
<div class="line">// Infinite with label</div>
<div class="line">outer: loop {</div>
<div class="line">    if done { break outer; }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Repeat N times</div>
<div class="line">for _ in 0..5 { ... }</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md39"></a>
Advanced Control</h4>
<div class="fragment"><div class="line">// Guard: Execute else and return if condition is false</div>
<div class="line">guard ptr != NULL else { return; }</div>
<div class="line"> </div>
<div class="line">// Unless: If not true</div>
<div class="line">unless is_valid { return; }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md40"></a>
6. Operators</h3>
<p>Zen C supports operator overloading for user-defined structs by implementing specific method names.</p>
<h4><a class="anchor" id="autotoc_md41"></a>
Overloadable Operators</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Category   </th><th class="markdownTableHeadLeft">Operator   </th><th class="markdownTableHeadLeft">Method Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Arithmetic</b>   </td><td class="markdownTableBodyLeft"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>   </td><td class="markdownTableBodyLeft"><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>rem</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Comparison</b>   </td><td class="markdownTableBodyLeft"><code>==</code>, <code>!=</code>   </td><td class="markdownTableBodyLeft"><code>eq</code>, <code>neq</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft"><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>   </td><td class="markdownTableBodyLeft"><code>lt</code>, <code>gt</code>, <code>le</code>, <code>ge</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Bitwise</b>   </td><td class="markdownTableBodyLeft"><code>&amp;</code>, <code>\|</code>, <code>^</code>   </td><td class="markdownTableBodyLeft"><code>bitand</code>, <code>bitor</code>, <code>bitxor</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft"><code>&lt;&lt;</code>, <code>&gt;&gt;</code>   </td><td class="markdownTableBodyLeft"><code>shl</code>, <code>shr</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Unary</b>   </td><td class="markdownTableBodyLeft"><code>-</code>   </td><td class="markdownTableBodyLeft"><code>neg</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft"><code>!</code>   </td><td class="markdownTableBodyLeft"><code>not</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft"><code>~</code>   </td><td class="markdownTableBodyLeft"><code>bitnot</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Index</b>   </td><td class="markdownTableBodyLeft"><code>a[i]</code>   </td><td class="markdownTableBodyLeft"><code>get(a, i)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"></td><td class="markdownTableBodyLeft"><code>a[i] = v</code>   </td><td class="markdownTableBodyLeft"><code>set(a, i, v)</code>   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;<b>Note on String Equality</b>:</p><ul>
<li><code>string == string</code> performs <b>value comparison</b> (equivalent to <code>strcmp</code>).</li>
<li><code>char* == char*</code> performs <b>pointer comparison</b> (checks memory addresses).</li>
<li>Mixed comparisons (e.g. <code>string == char*</code>) default to <b>pointer comparison</b>. </li>
</ul>
</blockquote>
<p><b>Example:</b> </p><div class="fragment"><div class="line">impl Point {</div>
<div class="line">    fn add(self, other: Point) -&gt; Point {</div>
<div class="line">        return Point{x: self.x + other.x, y: self.y + other.y};</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">let p3 = p1 + p2; // Calls p1.add(p2)</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md42"></a>
Syntactic Sugar</h4>
<p>These operators are built-in language features and cannot be overloaded directly.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Operator   </th><th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>\|&gt;</code>   </td><td class="markdownTableBodyLeft">Pipeline   </td><td class="markdownTableBodyLeft"><code>x \|&gt; f(y)</code> desugars to <code>f(x, y)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>??</code>   </td><td class="markdownTableBodyLeft">Null Coalescing   </td><td class="markdownTableBodyLeft"><code>val ?? default</code> returns <code>default</code> if <code>val</code> is NULL (pointers)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>??=</code>   </td><td class="markdownTableBodyLeft">Null Assignment   </td><td class="markdownTableBodyLeft"><code>val ??= init</code> assigns if <code>val</code> is NULL    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>?.</code>   </td><td class="markdownTableBodyLeft">Safe Navigation   </td><td class="markdownTableBodyLeft"><code>ptr?.field</code> accesses field only if <code>ptr</code> is not NULL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>?</code>   </td><td class="markdownTableBodyLeft">Try Operator   </td><td class="markdownTableBodyLeft"><code>res?</code> returns error if present (Result/Option types)   </td></tr>
</table>
<p><b>Auto-Dereference</b>: Pointer field access (<code>ptr.field</code>) and method calls (<code>ptr.method()</code>) automatically dereference the pointer, equivalent to <code>(*ptr).field</code>.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
7. Printing and String Interpolation</h3>
<p>Zen C provides versatile options for printing to the console, including keywords and concise shorthands.</p>
<h4><a class="anchor" id="autotoc_md44"></a>
Keywords</h4>
<ul>
<li><code>print "text"</code>: Prints to <code>stdout</code> without a trailing newline.</li>
<li><code>println "text"</code>: Prints to <code>stdout</code> with a trailing newline.</li>
<li><code>eprint "text"</code>: Prints to <code>stderr</code> without a trailing newline.</li>
<li><code>eprintln "text"</code>: Prints to <code>stderr</code> with a trailing newline.</li>
</ul>
<h4><a class="anchor" id="autotoc_md45"></a>
Shorthands</h4>
<p>Zen C allows you to use string literals directly as statements for quick printing:</p>
<ul>
<li><code>"Hello World"</code>: Equivalent to <code>println "Hello World"</code>. (Implicitly adds newline)</li>
<li><code>"Hello World"..</code>: Equivalent to <code>print "Hello World"</code>. (No trailing newline)</li>
<li><code>!"Error"</code>: Equivalent to <code>eprintln "Error"</code>. (Output to stderr)</li>
<li><code>!"Error"..</code>: Equivalent to <code>eprint "Error"</code>. (Output to stderr, no newline)</li>
</ul>
<h4><a class="anchor" id="autotoc_md46"></a>
String Interpolation (F-strings)</h4>
<p>You can embed expressions directly into string literals using <code>{}</code> syntax. This works with all printing methods and string shorthands.</p>
<div class="fragment"><div class="line">let x = 42;</div>
<div class="line">let name = &quot;Zen&quot;;</div>
<div class="line">println &quot;Value: {x}, Name: {name}&quot;;</div>
<div class="line">&quot;Value: {x}, Name: {name}&quot;; // shorthand println</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md47"></a>
Input Prompts (&lt;tt&gt;?&lt;/tt&gt;)</h4>
<p>Zen C supports a shorthand for prompting user input using the <code>?</code> prefix.</p>
<ul>
<li><code>? "Prompt text"</code>: Prints the prompt (without newline) and waits for input (reads a line).</li>
<li><code>? "Enter age: " (age)</code>: Prints prompt and scans input into the variable <code>age</code>.<ul>
<li>Format specifiers are automatically inferred based on variable type.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">let age: int;</div>
<div class="line">? &quot;How old are you? &quot; (age);</div>
<div class="line">println &quot;You are {age} years old.&quot;;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md48"></a>
8. Memory Management</h3>
<p>Zen C allows manual memory management with ergonomic aids.</p>
<h4><a class="anchor" id="autotoc_md49"></a>
Defer</h4>
<p>Execute code when the current scope exits. Defer statements are executed in LIFO (last-in, first-out) order. </p><div class="fragment"><div class="line">let f = fopen(&quot;file.txt&quot;, &quot;r&quot;);</div>
<div class="line">defer fclose(f);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;To prevent undefined behavior, control flow statements (<code>return</code>, <code>break</code>, <code>continue</code>, <code>goto</code>) are <b>not allowed</b> inside a <code>defer</code> block. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md50"></a>
Autofree</h4>
<p>Automatically free the variable when scope exits. </p><div class="fragment"><div class="line">autofree let types = malloc(1024);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md51"></a>
Resource Semantics (Move by Default)</h4>
<p>Zen C treats types with destructors (like <code>File</code>, <code>Vec</code>, or malloc'd pointers) as <b>Resources</b>. To prevent double-free errors, resources cannot be implicitly duplicated.</p>
<ul>
<li><b>Move by Default</b>: Assigning a resource variable transfers ownership. The original variable becomes invalid (Moved).</li>
<li><b>Copy Types</b>: Types without destructors may opt-in to <code>Copy</code> behavior, making assignment a duplication.</li>
</ul>
<p><b>Diagnostics &amp; Philosophy</b>: If you see an error "Use of moved value", the compiler is telling you: *"This type owns a resource (like memory or a handle) and blindly copying it is unsafe."*</p>
<blockquote class="doxtable">
<p>&zwj;<b>Contrast:</b> Unlike C/C++, Zen C does not implicitly duplicate resource-owning values. </p>
</blockquote>
<p><b>Function Arguments</b>: Passing a value to a function follows the same rules as assignment: resources are moved unless passed by reference.</p>
<div class="fragment"><div class="line">fn process(r: Resource) { ... } // &#39;r&#39; is moved into function</div>
<div class="line">fn peek(r: Resource*) { ... }   // &#39;r&#39; is borrowed (reference)</div>
</div><!-- fragment --><p><b>Explicit Cloning</b>: If you <em>do</em> want two copies of a resource, make it explicit:</p>
<div class="fragment"><div class="line">let b = a.clone(); // Calls the &#39;clone&#39; method from the Clone trait</div>
</div><!-- fragment --><p><b>Opt-in Copy (Value Types)</b>: For small types without destructors:</p>
<div class="fragment"><div class="line">struct Point { x: int; y: int; }</div>
<div class="line">impl Copy for Point {} // Opt-in to implicit duplication</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let p1 = Point { x: 1, y: 2 };</div>
<div class="line">    let p2 = p1; // Copied. p1 stays valid.</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md52"></a>
RAII / Drop Trait</h4>
<p>Implement <code>Drop</code> to run cleanup logic automatically. </p><div class="fragment"><div class="line">impl Drop for MyStruct {</div>
<div class="line">    fn drop(self) {</div>
<div class="line">        self.free();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md53"></a>
9. Object Oriented Programming</h3>
<h4><a class="anchor" id="autotoc_md54"></a>
Methods</h4>
<p>Define methods on types using <code>impl</code>. </p><div class="fragment"><div class="line">impl Point {</div>
<div class="line">    // Static method (constructor convention)</div>
<div class="line">    fn new(x: int, y: int) -&gt; Self {</div>
<div class="line">        return Point{x: x, y: y};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Instance method</div>
<div class="line">    fn dist(self) -&gt; float {</div>
<div class="line">        return sqrt(self.x * self.x + self.y * self.y);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md55"></a>
Traits</h4>
<p>Define shared behavior. </p><div class="fragment"><div class="line">struct Circle { radius: f32; }</div>
<div class="line"> </div>
<div class="line">trait Drawable {</div>
<div class="line">    fn draw(self);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">impl Drawable for Circle {</div>
<div class="line">    fn draw(self) { ... }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">let circle = Circle{};</div>
<div class="line">let drawable: Drawable = &amp;circle;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md56"></a>
Standard Traits</h4>
<p>Zen C includes standard traits that integrate with language syntax.</p>
<p><b>Iterable</b></p>
<p>Implement <code>Iterable&lt;T&gt;</code> to enable <code>for-in</code> loops for your custom types.</p>
<div class="fragment"><div class="line">import &quot;std/iter.zc&quot;</div>
<div class="line"> </div>
<div class="line">// Define an Iterator</div>
<div class="line">struct MyIter {</div>
<div class="line">    curr: int;</div>
<div class="line">    stop: int;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">impl MyIter {</div>
<div class="line">    fn next(self) -&gt; Option&lt;int&gt; {</div>
<div class="line">        if self.curr &lt; self.stop {</div>
<div class="line">            self.curr += 1;</div>
<div class="line">            return Option&lt;int&gt;::Some(self.curr - 1);</div>
<div class="line">        }</div>
<div class="line">        return Option&lt;int&gt;::None();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Implement Iterable</div>
<div class="line">impl MyRange {</div>
<div class="line">    fn iterator(self) -&gt; MyIter {</div>
<div class="line">        return MyIter{curr: self.start, stop: self.end};</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Use in Loop</div>
<div class="line">for i in my_range {</div>
<div class="line">    println &quot;{i}&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Drop</b></p>
<p>Implement <code>Drop</code> to define a destructor that runs when the object goes out of scope (RAII).</p>
<div class="fragment"><div class="line">import &quot;std/mem.zc&quot;</div>
<div class="line"> </div>
<div class="line">struct Resource {</div>
<div class="line">    ptr: void*;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">impl Drop for Resource {</div>
<div class="line">    fn drop(self) {</div>
<div class="line">        if self.ptr != NULL {</div>
<div class="line">            free(self.ptr);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note:</b> If a variable is moved, <code>drop</code> is NOT called on the original variable. It adheres to Resource Semantics. </p>
</blockquote>
<p><b>Copy</b></p>
<p>Marker trait to opt-in to <code>Copy</code> behavior (implicit duplication) instead of Move semantics. Used via <code>@derive(Copy)</code>.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Rule:</b> Types that implement <code>Copy</code> must not define a destructor (<code>Drop</code>). </p>
</blockquote>
<div class="fragment"><div class="line">@derive(Copy)</div>
<div class="line">struct Point { x: int; y: int; }</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let p1 = Point{x: 1, y: 2};</div>
<div class="line">    let p2 = p1; // Copied! p1 remains valid.</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Clone</b></p>
<p>Implement <code>Clone</code> to allow explicit duplication of resource-owning types.</p>
<div class="fragment"><div class="line">import &quot;std/mem.zc&quot;</div>
<div class="line"> </div>
<div class="line">struct MyBox { val: int; }</div>
<div class="line"> </div>
<div class="line">impl Clone for MyBox {</div>
<div class="line">    fn clone(self) -&gt; MyBox {</div>
<div class="line">        return MyBox{val: self.val};</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let b1 = MyBox{val: 42};</div>
<div class="line">    let b2 = b1.clone(); // Explicit copy</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md57"></a>
Composition</h4>
<p>Use <code>use</code> to embed other structs. You can either mix them in (flatten fields) or name them (nest fields).</p>
<div class="fragment"><div class="line">struct Entity { id: int; }</div>
<div class="line"> </div>
<div class="line">struct Player {</div>
<div class="line">    // Mixin (Unnamed): Flattens fields</div>
<div class="line">    use Entity;  // Adds &#39;id&#39; to Player directly</div>
<div class="line">    name: string;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct Match {</div>
<div class="line">    // Composition (Named): Nests fields</div>
<div class="line">    use p1: Player; // Accessed via match.p1</div>
<div class="line">    use p2: Player; // Accessed via match.p2</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md58"></a>
10. Generics</h3>
<p>Type-safe templates for Structs and Functions.</p>
<div class="fragment"><div class="line">// Generic Struct</div>
<div class="line">struct Box&lt;T&gt; {</div>
<div class="line">    item: T;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Generic Function</div>
<div class="line">fn identity&lt;T&gt;(val: T) -&gt; T {</div>
<div class="line">    return val;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Multi-parameter Generics</div>
<div class="line">struct Pair&lt;K, V&gt; {</div>
<div class="line">    key: K;</div>
<div class="line">    value: V;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md59"></a>
11. Concurrency (Async/Await)</h3>
<p>Built on pthreads.</p>
<div class="fragment"><div class="line">async fn fetch_data() -&gt; string {</div>
<div class="line">    // Runs in background</div>
<div class="line">    return &quot;Data&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let future = fetch_data();</div>
<div class="line">    let result = await future;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md60"></a>
12. Metaprogramming</h3>
<h4><a class="anchor" id="autotoc_md61"></a>
Comptime</h4>
<p>Run code at compile-time to generate source or print messages. </p><div class="fragment"><div class="line">comptime {</div>
<div class="line">    // Generate code at compile-time (written to stdout)</div>
<div class="line">    println &quot;let build_date = \&quot;2024-01-01\&quot;;&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">println &quot;Build Date: {build_date}&quot;;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md62"></a>
Embed</h4>
<p>Embed files as specified types. </p><div class="fragment"><div class="line">// Default (Slice_char)</div>
<div class="line">let data = embed &quot;assets/logo.png&quot;;</div>
<div class="line"> </div>
<div class="line">// Typed Embed</div>
<div class="line">let text = embed &quot;shader.glsl&quot; as string;    // Embbed as C-string</div>
<div class="line">let rom  = embed &quot;bios.bin&quot; as u8[1024];     // Embed as fixed array</div>
<div class="line">let wav  = embed &quot;sound.wav&quot; as u8[];        // Embed as Slice_u8</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md63"></a>
Plugins</h4>
<p>Import compiler plugins to extend syntax. </p><div class="fragment"><div class="line">import plugin &quot;regex&quot;</div>
<div class="line">let re = regex! { ^[a-z]+$ };</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md64"></a>
Generic C Macros</h4>
<p>Pass preprocessor macros through to C.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Tip</b>: For simple constants, use <code>def</code> instead. Use <code>#define</code> when you need C-preprocessor macros or conditional compilation flags. </p>
</blockquote>
<div class="fragment"><div class="line">#define MAX_BUFFER 1024</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
13. Attributes</h3>
<p>Decorate functions and structs to modify compiler behavior.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><a class="el" href="structAttribute.html">Attribute</a>   </th><th class="markdownTableHeadLeft"><a class="el" href="structScope.html" title="Represents a lexical scope (block).">Scope</a>   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@must_use</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Warn if return value is ignored.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@deprecated("msg")</code>   </td><td class="markdownTableBodyLeft">Fn/Struct   </td><td class="markdownTableBodyLeft">Warn on usage with message.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@inline</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Hint compiler to inline.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@noinline</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Prevent inlining.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@packed</code>   </td><td class="markdownTableBodyLeft">Struct   </td><td class="markdownTableBodyLeft">Remove padding between fields.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@align(N)</code>   </td><td class="markdownTableBodyLeft">Struct   </td><td class="markdownTableBodyLeft">Force alignment to N bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@constructor</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Run before main.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@destructor</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Run after main exits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@unused</code>   </td><td class="markdownTableBodyLeft">Fn/Var   </td><td class="markdownTableBodyLeft">Suppress unused variable warnings.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@weak</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Weak symbol linkage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@section("name")</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Place code in specific section.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@noreturn</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Function does not return (e.g. exit).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@pure</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Function has no side effects (optimization hint).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@cold</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Function is unlikely to be executed (branch prediction hint).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@hot</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Function is frequently executed (optimization hint).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@export</code>   </td><td class="markdownTableBodyLeft">Fn/Struct   </td><td class="markdownTableBodyLeft">Export symbol (visibility default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@global</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">CUDA: Kernel entry point (<code>__global__</code>).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@device</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">CUDA: Device function (<code>__device__</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@host</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">CUDA: Host function (<code>__host__</code>).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@comptime</code>   </td><td class="markdownTableBodyLeft">Fn   </td><td class="markdownTableBodyLeft">Helper function available for compile-time execution.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@derive(...)</code>   </td><td class="markdownTableBodyLeft">Struct   </td><td class="markdownTableBodyLeft">Auto-implement traits. Supports <code>Debug</code>, <code>Eq</code> (Smart Derive), <code>Copy</code>, <code>Clone</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@ctype("type")</code>   </td><td class="markdownTableBodyLeft">Fn Param   </td><td class="markdownTableBodyLeft">Overrides generated C type for a parameter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@&lt;custom&gt;</code>   </td><td class="markdownTableBodyLeft">Any   </td><td class="markdownTableBodyLeft">Passes generic attributes to C (e.g. <code>@flatten</code>, <code>@alias("name")</code>).   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md66"></a>
Custom Attributes</h4>
<p>Zen C supports a powerful <b>Custom <a class="el" href="structAttribute.html">Attribute</a></b> system that allows you to use any GCC/Clang <code>__attribute__</code> directly in your code. Any attribute that is not explicitly recognized by the Zen C compiler is treated as a generic attribute and passed through to the generated C code.</p>
<p>This provides access to advanced compiler features, optimizations, and linker directives without needing explicit support in the language core.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
Syntax Mapping</h4>
<p>Zen C attributes are mapped directly to C attributes:</p><ul>
<li><code>@name</code> → <code>__attribute__((name))</code></li>
<li><code>@<a class="el" href="cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name(args)</a></code> → <code>__attribute__((<a class="el" href="cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name(args)</a>))</code></li>
<li><code>@name("string")</code> → <code>__attribute__((name("string")))</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md68"></a>
Smart Derives</h4>
<p>Zen C provides "Smart Derives" that respect Move Semantics:</p>
<ul>
<li>**<code>@derive(Eq)</code>**: Generates an equality method that takes arguments by reference (<code>fn eq(self, other: T*)</code>).<ul>
<li>When comparing two non-Copy structs (<code>a == b</code>), the compiler automatically passes <code>b</code> by reference (<code>&amp;b</code>) to avoid moving it.</li>
<li>Recursive equality checks on fields also prefer pointer access to prevent ownership transfer.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md69"></a>
14. Inline Assembly</h3>
<p>Zen C provides first-class support for inline assembly, transpiling directly to GCC-style extended <code>asm</code>.</p>
<h4><a class="anchor" id="autotoc_md70"></a>
Basic Usage</h4>
<p>Write raw assembly within <code>asm</code> blocks. Strings are concatenated automatically. </p><div class="fragment"><div class="line">asm {</div>
<div class="line">    &quot;nop&quot;</div>
<div class="line">    &quot;mfence&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md71"></a>
Volatile</h4>
<p>Prevent the compiler from optimizing away assembly that has side effects. </p><div class="fragment"><div class="line">asm volatile {</div>
<div class="line">    &quot;rdtsc&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md72"></a>
Named Constraints</h4>
<p>Zen C simplifies the complex GCC constraint syntax with named bindings.</p>
<div class="fragment"><div class="line">// Syntax: : out(variable) : in(variable) : clobber(reg)</div>
<div class="line">// Uses {variable} placeholder syntax for readability</div>
<div class="line"> </div>
<div class="line">fn add_five(x: int) -&gt; int {</div>
<div class="line">    let result: int;</div>
<div class="line">    asm {</div>
<div class="line">        &quot;mov {x}, {result}&quot;</div>
<div class="line">        &quot;add $5, {result}&quot;</div>
<div class="line">        : out(result)</div>
<div class="line">        : in(x)</div>
<div class="line">        : clobber(&quot;cc&quot;)</div>
<div class="line">    }</div>
<div class="line">    return result;</div>
<div class="line">}</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><a class="el" href="structType.html" title="Represents a formal type in the type system.">Type</a>   </th><th class="markdownTableHeadLeft">Syntax   </th><th class="markdownTableHeadLeft">GCC Equivalent    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Output</b>   </td><td class="markdownTableBodyLeft"><code>: out(variable)</code>   </td><td class="markdownTableBodyLeft"><code>"=r"(variable)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Input</b>   </td><td class="markdownTableBodyLeft"><code>: in(variable)</code>   </td><td class="markdownTableBodyLeft"><code>"r"(variable)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Clobber</b>   </td><td class="markdownTableBodyLeft"><code>: clobber("rax")</code>   </td><td class="markdownTableBodyLeft"><code>"rax"</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Memory</b>   </td><td class="markdownTableBodyLeft"><code>: clobber("memory")</code>   </td><td class="markdownTableBodyLeft"><code>"memory"</code>   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> When using Intel syntax (via <code>-masm=intel</code>), you must ensure your build is configured correctly (for example, <code>//&gt; cflags: -masm=intel</code>). TCC does not support Intel syntax assembly. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md73"></a>
15. Build Directives</h3>
<p>Zen C supports special comments at the top of your source file to configure the build process without needing a complex build system or Makefile.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Directive   </th><th class="markdownTableHeadLeft">Arguments   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>//&gt; link:</code>   </td><td class="markdownTableBodyLeft"><code>-lfoo</code> or <code>path/to/lib.a</code>   </td><td class="markdownTableBodyLeft">Link against a library or object file.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>//&gt; lib:</code>   </td><td class="markdownTableBodyLeft"><code>path/to/libs</code>   </td><td class="markdownTableBodyLeft">Add a library search path (<code>-L</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>//&gt; include:</code>   </td><td class="markdownTableBodyLeft"><code>path/to/headers</code>   </td><td class="markdownTableBodyLeft">Add an include search path (<code>-I</code>).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>//&gt; framework:</code>   </td><td class="markdownTableBodyLeft"><code>Cocoa</code>   </td><td class="markdownTableBodyLeft">Link against a macOS framework.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>//&gt; cflags:</code>   </td><td class="markdownTableBodyLeft"><code>-Wall -O3</code>   </td><td class="markdownTableBodyLeft">Pass arbitrary flags to the C compiler.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>//&gt; define:</code>   </td><td class="markdownTableBodyLeft"><code>MACRO</code> or <code>KEY=VAL</code>   </td><td class="markdownTableBodyLeft">Define a preprocessor macro (<code>-D</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>//&gt; pkg-config:</code>   </td><td class="markdownTableBodyLeft"><code>gtk+-3.0</code>   </td><td class="markdownTableBodyLeft">Run <code>pkg-config</code> and append <code>--cflags</code> and <code>--libs</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>//&gt; shell:</code>   </td><td class="markdownTableBodyLeft"><code>command</code>   </td><td class="markdownTableBodyLeft">Execute a shell command during the build.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>//&gt; get:</code>   </td><td class="markdownTableBodyLeft"><code><a href="http://url/file">http://url/file</a></code>   </td><td class="markdownTableBodyLeft">Download a file if specific file does not exist.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md74"></a>
Features</h4>
<p><b>1. OS Guarding</b> Prefix directives with an OS name to apply them only on specific platforms. Supported prefixes: <code>linux:</code>, <code>windows:</code>, <code>macos:</code> (or <code>darwin:</code>).</p>
<div class="fragment"><div class="line">//&gt; linux: link: -lm</div>
<div class="line">//&gt; windows: link: -lws2_32</div>
<div class="line">//&gt; macos: framework: Cocoa</div>
</div><!-- fragment --><p><b>2. Environment Variable Expansion</b> Use <code>${VAR}</code> syntax to expand environment variables in your directives.</p>
<div class="fragment"><div class="line">//&gt; include: ${HOME}/mylib/include</div>
<div class="line">//&gt; lib: ${ZC_ROOT}/std</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md75"></a>
Examples</h4>
<div class="fragment"><div class="line">//&gt; include: ./include</div>
<div class="line">//&gt; lib: ./libs</div>
<div class="line">//&gt; link: -lraylib -lm</div>
<div class="line">//&gt; cflags: -Ofast</div>
<div class="line">//&gt; pkg-config: gtk+-3.0</div>
<div class="line"> </div>
<div class="line">import &quot;raylib.h&quot;</div>
<div class="line"> </div>
<div class="line">fn main() { ... }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md76"></a>
16. Keywords</h3>
<p>The following keywords are reserved in Zen C.</p>
<h4><a class="anchor" id="autotoc_md77"></a>
Declarations</h4>
<p><code>alias</code>, <code>def</code>, <code>enum</code>, <code>fn</code>, <code>impl</code>, <code>import</code>, <code>let</code>, <code>module</code>, <code>opaque</code>, <code>struct</code>, <code>trait</code>, <code>union</code>, <code>use</code></p>
<h4><a class="anchor" id="autotoc_md78"></a>
Control Flow</h4>
<p><code>async</code>, <code>await</code>, <code>break</code>, <code>catch</code>, <code>continue</code>, <code>defer</code>, <code>else</code>, <code>for</code>, <code>goto</code>, <code>guard</code>, <code>if</code>, <code>loop</code>, <code>match</code>, <code>return</code>, <code>try</code>, <code>unless</code>, <code>while</code></p>
<h4><a class="anchor" id="autotoc_md79"></a>
Special</h4>
<p><code>asm</code>, <code>assert</code>, <code>autofree</code>, <code>comptime</code>, <code>const</code>, <code>embed</code>, <code>launch</code>, <code>ref</code>, <code>sizeof</code>, <code>static</code>, <code>test</code>, <code>volatile</code></p>
<h4><a class="anchor" id="autotoc_md80"></a>
Constants</h4>
<p><code>true</code>, <code>false</code>, <code>null</code></p>
<h4><a class="anchor" id="autotoc_md81"></a>
C Reserved</h4>
<p>The following identifiers are reserved because they are keywords in C11: <code>auto</code>, <code>case</code>, <code>char</code>, <code>default</code>, <code>do</code>, <code>double</code>, <code>extern</code>, <code>float</code>, <code>inline</code>, <code>int</code>, <code>long</code>, <code>register</code>, <code>restrict</code>, <code>short</code>, <code>signed</code>, <code>switch</code>, <code>typedef</code>, <code>unsigned</code>, <code>void</code>, <code>_Atomic</code>, <code>_Bool</code>, <code>_Complex</code>, <code>_Generic</code>, <code>_Imaginary</code>, <code>_Noreturn</code>, <code>_Static_assert</code>, <code>_Thread_local</code></p>
<h4><a class="anchor" id="autotoc_md82"></a>
Operators</h4>
<p><code>and</code>, <code>or</code></p>
<h3><a class="anchor" id="autotoc_md83"></a>
17. C Interoperability</h3>
<p>Zen C offers two ways to interact with C code: <b>Trusted Imports</b> (Convenient) and <b>Explicit FFI</b> (Safe/Precise).</p>
<h4><a class="anchor" id="autotoc_md84"></a>
Method 1: Trusted Imports (Convenient)</h4>
<p>You can import a C header directly using the <code>import</code> keyword with the <code>.h</code> extension. This treats the header as a module and assumes all symbols accessed through it exist.</p>
<div class="fragment"><div class="line">//&gt; link: -lm</div>
<div class="line">import &quot;math.h&quot; as c_math;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    // Compiler trusts correctness; emits &#39;cos(...)&#39; directly</div>
<div class="line">    let x = c_math::cos(3.14159);</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Pros</b>: Zero boilerplate. Access everything in the header immediately. <b>Cons</b>: No type safety from Zen C (errors caught by C compiler later). </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md85"></a>
Method 2: Explicit FFI (Safe)</h4>
<p>For strict type checking or when you don't want to include the text of a header, use <code>extern fn</code>.</p>
<div class="fragment"><div class="line">include &lt;stdio.h&gt; // Emits #include &lt;stdio.h&gt; in generated C</div>
<div class="line"> </div>
<div class="line">// Define strict signature</div>
<div class="line">extern fn printf(fmt: char*, ...) -&gt; c_int;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    printf(&quot;Hello FFI: %d\n&quot;, 42); // Type checked by Zen C</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Pros</b>: Zen C ensures types match. <b>Cons</b>: Requires manual declaration of functions. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md86"></a>
&lt;tt&gt;import&lt;/tt&gt; vs &lt;tt&gt;include&lt;/tt&gt;</h4>
<ul>
<li>**<code>import "file.h"</code>**: Registers the header as a named module. Enables implicit access to symbols (for example, <code><a href="file::function()">file::function()</a></code>).</li>
<li>**<code>include &lt;file.h&gt;</code>**: Purely emits <code>#include &lt;file.h&gt;</code> in the generated C code. Does not introduce any symbols to the Zen C compiler; you must use <code>extern fn</code> to access them.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md88"></a>
Standard Library</h2>
<p>Zen C includes a standard library (<code>std</code>) covering essential functionality.</p>
<p>Browse the Standard Library Documentation</p>
<h3><a class="anchor" id="autotoc_md89"></a>
Key Modules</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><a class="el" href="structModule.html" title="Represents a module (namespace/file).">Module</a>   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadLeft">Docs    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/vec.zc</code>**   </td><td class="markdownTableBodyLeft">Growable dynamic array <code>Vec&lt;T&gt;</code>.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/string.zc</code>**   </td><td class="markdownTableBodyLeft">Heap-allocated <code>String</code> type with UTF-8 support.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/queue.zc</code>**   </td><td class="markdownTableBodyLeft">FIFO queue (Ring Buffer).   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/map.zc</code>**   </td><td class="markdownTableBodyLeft">Generic Hash Map <code>Map&lt;V&gt;</code>.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/fs.zc</code>**   </td><td class="markdownTableBodyLeft">File system operations.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/io.zc</code>**   </td><td class="markdownTableBodyLeft">Standard Input/Output (<code>print</code>/<code>println</code>).   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/option.zc</code>**   </td><td class="markdownTableBodyLeft">Optional values (<code>Some</code>/<code>None</code>).   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/result.zc</code>**   </td><td class="markdownTableBodyLeft">Error handling (<code>Ok</code>/<code>Err</code>).   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/path.zc</code>**   </td><td class="markdownTableBodyLeft">Cross-platform path manipulation.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/env.zc</code>**   </td><td class="markdownTableBodyLeft">Process environment variables.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/net.zc</code>**   </td><td class="markdownTableBodyLeft">TCP networking (Sockets).   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/thread.zc</code>**   </td><td class="markdownTableBodyLeft">Threads and Synchronization.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/time.zc</code>**   </td><td class="markdownTableBodyLeft">Time measurement and sleep.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/json.zc</code>**   </td><td class="markdownTableBodyLeft">JSON parsing and serialization.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/stack.zc</code>**   </td><td class="markdownTableBodyLeft">LIFO Stack <code>Stack&lt;T&gt;</code>.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">**<code>std/set.zc</code>**   </td><td class="markdownTableBodyLeft">Generic Hash Set <code>Set&lt;T&gt;</code>.   </td><td class="markdownTableBodyLeft">Docs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">**<code>std/process.zc</code>**   </td><td class="markdownTableBodyLeft">Process execution and management.   </td><td class="markdownTableBodyLeft">Docs   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md91"></a>
Tooling</h2>
<p>Zen C provides a built-in Language Server and REPL to enhance the development experience.</p>
<h3><a class="anchor" id="autotoc_md92"></a>
Language Server (LSP)</h3>
<p>The Zen C Language Server (LSP) supports standard LSP features for editor integration, providing:</p>
<ul>
<li><b>Go to Definition</b></li>
<li><b>Find References</b></li>
<li><b>Hover Information</b></li>
<li><b>Completion</b> (Function/Struct names, Dot-completion for methods/fields)</li>
<li><b>Document Symbols</b> (Outline)</li>
<li><b>Signature Help</b></li>
<li><b>Diagnostics</b> (Syntax/Semantic errors)</li>
</ul>
<p>To start the language server (typically configured in your editor's LSP settings):</p>
<div class="fragment"><div class="line">zc lsp</div>
</div><!-- fragment --><p>It communicates via standard I/O (JSON-RPC 2.0).</p>
<h3><a class="anchor" id="autotoc_md93"></a>
REPL</h3>
<p>The Read-Eval-Print Loop allows you to experiment with Zen C code interactively.</p>
<div class="fragment"><div class="line">zc repl</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md94"></a>
Features</h4>
<ul>
<li><b>Interactive Coding</b>: <a class="el" href="structType.html" title="Represents a formal type in the type system.">Type</a> expressions or statements for immediate evaluation.</li>
<li><b>Persistent History</b>: Commands are saved to <code>~/.zprep_history</code>.</li>
<li><b>Startup Script</b>: Auto-loads commands from <code>~/.zprep_init.zc</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md95"></a>
Commands</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Command   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:help</code>   </td><td class="markdownTableBodyLeft">Show available commands.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:reset</code>   </td><td class="markdownTableBodyLeft">Clear current session history (variables/functions).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:vars</code>   </td><td class="markdownTableBodyLeft">Show active variables.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:funcs</code>   </td><td class="markdownTableBodyLeft">Show user-defined functions.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:structs</code>   </td><td class="markdownTableBodyLeft">Show user-defined structs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:imports</code>   </td><td class="markdownTableBodyLeft">Show active imports.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:history</code>   </td><td class="markdownTableBodyLeft">Show session input history.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:type &lt;expr&gt;</code>   </td><td class="markdownTableBodyLeft">Show the type of an expression.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:c &lt;stmt&gt;</code>   </td><td class="markdownTableBodyLeft">Show the generated C code for a statement.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:time &lt;expr&gt;</code>   </td><td class="markdownTableBodyLeft">Benchmark an expression (runs 1000 iterations).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:edit [n]</code>   </td><td class="markdownTableBodyLeft">Edit command <code>n</code> (default: last) in <code>$EDITOR</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:save &lt;file&gt;</code>   </td><td class="markdownTableBodyLeft">Save the current session to a <code>.zc</code> file.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:load &lt;file&gt;</code>   </td><td class="markdownTableBodyLeft">Load and execute a <code>.zc</code> file into the session.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:watch &lt;expr&gt;</code>   </td><td class="markdownTableBodyLeft">Watch an expression (re-evaluated after every entry).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:unwatch &lt;n&gt;</code>   </td><td class="markdownTableBodyLeft">Remove a watch.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:undo</code>   </td><td class="markdownTableBodyLeft">Remove the last command from the session.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:delete &lt;n&gt;</code>   </td><td class="markdownTableBodyLeft">Remove command at index <code>n</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>:clear</code>   </td><td class="markdownTableBodyLeft">Clear the screen.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>:quit</code>   </td><td class="markdownTableBodyLeft">Exit the REPL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>! &lt;cmd&gt;</code>   </td><td class="markdownTableBodyLeft">Run a shell command (e.g. <code>!ls</code>).   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md97"></a>
Compiler Support &amp; Compatibility</h2>
<p>Zen C is designed to work with most C11 compilers. Some features rely on GNU C extensions, but these often work in other compilers. Use the <code>--cc</code> flag to switch backends.</p>
<div class="fragment"><div class="line">zc run app.zc --cc clang</div>
<div class="line">zc run app.zc --cc zig</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md98"></a>
Test Suite Status</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Compiler   </th><th class="markdownTableHeadCenter">Pass Rate   </th><th class="markdownTableHeadLeft">Supported Features   </th><th class="markdownTableHeadLeft">Known Limitations    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>GCC</b>   </td><td class="markdownTableBodyCenter"><b>100%</b>   </td><td class="markdownTableBodyLeft">All Features   </td><td class="markdownTableBodyLeft">None.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Clang</b>   </td><td class="markdownTableBodyCenter"><b>100%</b>   </td><td class="markdownTableBodyLeft">All Features   </td><td class="markdownTableBodyLeft">None.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Zig</b>   </td><td class="markdownTableBodyCenter"><b>100%</b>   </td><td class="markdownTableBodyLeft">All Features   </td><td class="markdownTableBodyLeft">None. Uses <code>zig cc</code> as a drop-in C compiler.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>TCC</b>   </td><td class="markdownTableBodyCenter">**~70%**   </td><td class="markdownTableBodyLeft">Basic Syntax, Generics, Traits   </td><td class="markdownTableBodyLeft">No <code>__auto_type</code>, No Intel ASM, No Nested Functions.   </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;<b>Recommendation:</b> Use <b>GCC</b>, <b>Clang</b>, or <b>Zig</b> for production builds. TCC is excellent for rapid prototyping due to its compilation speed but misses some advanced C extensions Zen C relies on for full feature support. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md99"></a>
Building with Zig</h3>
<p>Zig's <code>zig cc</code> command provides a drop-in replacement for GCC/Clang with excellent cross-compilation support. To use Zig:</p>
<div class="fragment"><div class="line"># Compile and run a Zen C program with Zig</div>
<div class="line">zc run app.zc --cc zig</div>
<div class="line"> </div>
<div class="line"># Build the Zen C compiler itself with Zig</div>
<div class="line">make zig</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md100"></a>
C++ Interop</h3>
<p>Zen C can generate C++-compatible code with the <code>--cpp</code> flag, allowing seamless integration with C++ libraries.</p>
<div class="fragment"><div class="line"># Direct compilation with g++</div>
<div class="line">zc app.zc --cpp</div>
<div class="line"> </div>
<div class="line"># Or transpile for manual build</div>
<div class="line">zc transpile app.zc --cpp</div>
<div class="line">g++ out.c my_cpp_lib.o -o app</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md101"></a>
Using C++ in Zen C</h4>
<p>Include C++ headers and use raw blocks for C++ code:</p>
<div class="fragment"><div class="line">include &lt;vector&gt;</div>
<div class="line">include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">raw {</div>
<div class="line">    std::vector&lt;int&gt; make_vec(int a, int b) {</div>
<div class="line">        return {a, b};</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let v = make_vec(1, 2);</div>
<div class="line">    raw { std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl; }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note:</b> The <code>--cpp</code> flag switches the backend to <code>g++</code> and emits C++-compatible code (uses <code>auto</code> instead of <code>__auto_type</code>, function overloads instead of <code>_Generic</code>, and explicit casts for <code>void*</code>). </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md102"></a>
CUDA Interop</h4>
<p>Zen C supports GPU programming by transpiling to <b>CUDA C++</b>. This allows you to leverage powerful C++ features (templates, constexpr) within your kernels while maintaining Zen C's ergonomic syntax.</p>
<div class="fragment"><div class="line"># Direct compilation with nvcc</div>
<div class="line">zc run app.zc --cuda</div>
<div class="line"> </div>
<div class="line"># Or transpile for manual build</div>
<div class="line">zc transpile app.zc --cuda -o app.cu</div>
<div class="line">nvcc app.cu -o app</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md103"></a>
CUDA-Specific Attributes</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><a class="el" href="structAttribute.html">Attribute</a>   </th><th class="markdownTableHeadLeft">CUDA Equivalent   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@global</code>   </td><td class="markdownTableBodyLeft"><code>__global__</code>   </td><td class="markdownTableBodyLeft">Kernel function (runs on GPU, called from host)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>@device</code>   </td><td class="markdownTableBodyLeft"><code>__device__</code>   </td><td class="markdownTableBodyLeft">Device function (runs on GPU, called from GPU)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>@host</code>   </td><td class="markdownTableBodyLeft"><code>__host__</code>   </td><td class="markdownTableBodyLeft">Host function (explicit CPU-only)   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md104"></a>
Kernel Launch Syntax</h4>
<p>Zen C provides a clean <code>launch</code> statement for invoking CUDA kernels:</p>
<div class="fragment"><div class="line">launch kernel_name(args) with {</div>
<div class="line">    grid: num_blocks,</div>
<div class="line">    block: threads_per_block,</div>
<div class="line">    shared_mem: 1024,  // Optional</div>
<div class="line">    stream: my_stream   // Optional</div>
<div class="line">};</div>
</div><!-- fragment --><p>This transpiles to: <code>kernel_name&lt;&lt;&lt;grid, block, shared, stream&gt;&gt;&gt;(args);</code></p>
<h4><a class="anchor" id="autotoc_md105"></a>
Writing CUDA Kernels</h4>
<p>Use Zen C function syntax with <code>@global</code> and the <code>launch</code> statement:</p>
<div class="fragment"><div class="line">import &quot;std/cuda.zc&quot;</div>
<div class="line"> </div>
<div class="line">@global</div>
<div class="line">fn add_kernel(a: float*, b: float*, c: float*, n: int) {</div>
<div class="line">    let i = thread_id();</div>
<div class="line">    if i &lt; n {</div>
<div class="line">        c[i] = a[i] + b[i];</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    def N = 1024;</div>
<div class="line">    let d_a = cuda_alloc&lt;float&gt;(N);</div>
<div class="line">    let d_b = cuda_alloc&lt;float&gt;(N); </div>
<div class="line">    let d_c = cuda_alloc&lt;float&gt;(N);</div>
<div class="line">    defer cuda_free(d_a);</div>
<div class="line">    defer cuda_free(d_b);</div>
<div class="line">    defer cuda_free(d_c);</div>
<div class="line"> </div>
<div class="line">    // ... init data ...</div>
<div class="line">    </div>
<div class="line">    launch add_kernel(d_a, d_b, d_c, N) with {</div>
<div class="line">        grid: (N + 255) / 256,</div>
<div class="line">        block: 256</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    cuda_sync();</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md106"></a>
Standard Library (&lt;tt&gt;std/cuda.zc&lt;/tt&gt;)</h4>
<p>Zen C provides a standard library for common CUDA operations to reduce <code>raw</code> blocks:</p>
<div class="fragment"><div class="line">import &quot;std/cuda.zc&quot;</div>
<div class="line"> </div>
<div class="line">// Memory management</div>
<div class="line">let d_ptr = cuda_alloc&lt;float&gt;(1024);</div>
<div class="line">cuda_copy_to_device(d_ptr, h_ptr, 1024 * sizeof(float));</div>
<div class="line">defer cuda_free(d_ptr);</div>
<div class="line"> </div>
<div class="line">// Synchronization</div>
<div class="line">cuda_sync();</div>
<div class="line"> </div>
<div class="line">// Thread Indexing (use inside kernels)</div>
<div class="line">let i = thread_id(); // Global index</div>
<div class="line">let bid = block_id();</div>
<div class="line">let tid = local_id();</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note:</b> The <code>--cuda</code> flag sets <code>nvcc</code> as the compiler and implies <code>--cpp</code> mode. Requires the NVIDIA CUDA Toolkit. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md107"></a>
C23 Support</h3>
<p>Zen C supports modern C23 features when using a compatible backend compiler (GCC 14+, Clang 14+, TCC (partial)).</p>
<ul>
<li>**<code>auto</code>**: Zen C automatically maps type inference to standard C23 <code>auto</code> if <code>__STDC_VERSION__ &gt;= 202300L</code>.</li>
<li>**<code>_BitInt(N)</code>**: Use <code>iN</code> and <code>uN</code> types (e.g., <code>i256</code>, <code>u12</code>, <code>i24</code>) to access C23 arbitrary-width integers.</li>
</ul>
<h3><a class="anchor" id="autotoc_md108"></a>
Objective-C Interop</h3>
<p>Zen C can compile to Objective-C (<code>.m</code>) using the <code>--objc</code> flag, allowing you to use Objective-C frameworks (like Cocoa/Foundation) and syntax.</p>
<div class="fragment"><div class="line"># Compile with clang (or gcc/gnustep)</div>
<div class="line">zc app.zc --objc --cc clang</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md109"></a>
Using Objective-C in Zen C</h4>
<p>Use <code>include</code> for headers and <code>raw</code> blocks for Objective-C syntax (<code>@interface</code>, <code>[...]</code>, <code>@""</code>).</p>
<div class="fragment"><div class="line">//&gt; macos: framework: Foundation</div>
<div class="line">//&gt; linux: cflags: -fconstant-string-class=NSConstantString -D_NATIVE_OBJC_EXCEPTIONS</div>
<div class="line">//&gt; linux: link: -lgnustep-base -lobjc</div>
<div class="line"> </div>
<div class="line">include &lt;Foundation/Foundation.h&gt;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    raw {</div>
<div class="line">        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</div>
<div class="line">        NSLog(@&quot;Hello from Objective-C!&quot;);</div>
<div class="line">        [pool drain];</div>
<div class="line">    }</div>
<div class="line">    println &quot;Zen C works too!&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;<b>Note:</b> Zen C string interpolation works with Objective-C objects (<code>id</code>) by calling <code>debugDescription</code> or <code>description</code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md110"></a>
&lt;/blockquote&gt;</h2>
<h2><a class="anchor" id="autotoc_md111"></a>
Contributing</h2>
<p>We welcome contributions! Whether it's fixing bugs, adding documentation, or proposing new features.</p>
<h3><a class="anchor" id="autotoc_md112"></a>
How to Contribute</h3>
<ol type="1">
<li><b>Fork the Repository</b>: standard GitHub workflow.</li>
<li><b>Create a Feature Branch</b>: <code>git checkout -b feature/NewThing</code>.</li>
<li><b>Code Guidelines</b>:<ul>
<li>Follow the existing C style.</li>
<li>Ensure all tests pass: <code>make test</code>.</li>
<li>Add new tests for your feature in <code>tests/</code>.</li>
</ul>
</li>
<li><b>Submit a Pull Request</b>: Describe your changes clearly.</li>
</ol>
<h3><a class="anchor" id="autotoc_md113"></a>
Running Tests</h3>
<p>The test suite is your best friend.</p>
<div class="fragment"><div class="line"># Run all tests (GCC)</div>
<div class="line">make test</div>
<div class="line"> </div>
<div class="line"># Run specific test</div>
<div class="line">./zc run tests/test_match.zc</div>
<div class="line"> </div>
<div class="line"># Run with different compiler</div>
<div class="line">./tests/run_tests.sh --cc clang</div>
<div class="line">./tests/run_tests.sh --cc zig</div>
<div class="line">./tests/run_tests.sh --cc tcc</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md114"></a>
Extending the Compiler</h3>
<ul>
<li><b>Parser</b>: <code>src/parser/</code> - Recursive descent parser.</li>
<li><b>Codegen</b>: <code>src/codegen/</code> - Transpiler logic (Zen C -&gt; GNU C/C11).</li>
<li><b>Standard Library</b>: <code>std/</code> - Written in Zen C itself.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md116"></a>
Attributions</h2>
<p>This project uses third-party libraries. Full license texts can be found in the <code>LICENSES/</code> directory.</p>
<ul>
<li><b><a href="https://github.com/DaveGamble/cJSON">cJSON</a></b> (MIT License): Used for JSON parsing and generation in the Language Server.</li>
<li><b><a href="https://github.com/OEvgeny/zc-ape">zc-ape</a></b> (MIT License): The original Actually Portable Executable port of Zen-C by <a href="https://github.com/OEvgeny">Eugene Olonov</a>.</li>
<li><b><a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a></b> (ISC License): The foundational library that makes APE possible. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
